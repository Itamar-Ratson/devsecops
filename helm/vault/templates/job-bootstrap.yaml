{{- if .Values.bootstrap.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: vault-bootstrap
  namespace: {{ .Release.Namespace }}
  labels:
    app.kubernetes.io/name: vault-bootstrap
    app.kubernetes.io/instance: {{ .Release.Name }}
  annotations:
    # Run after Vault is deployed
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
spec:
  ttlSecondsAfterFinished: 300
  template:
    metadata:
      labels:
        app.kubernetes.io/name: vault-bootstrap
    spec:
      serviceAccountName: {{ .Release.Name }}
      restartPolicy: OnFailure
      containers:
        - name: bootstrap
          image: hashicorp/vault:1.18
          env:
            - name: VAULT_ADDR
              value: "http://{{ .Release.Name }}.{{ .Release.Namespace }}.svc:{{ .Values.ports.vault.http }}"
          command: ["/bin/sh", "-c"]
          args:
            - |
              set -e

              echo "=== Vault Bootstrap Script ==="

              # Kubernetes API helpers (replaces kubectl dependency)
              SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
              cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt >> /etc/ssl/certs/ca-certificates.crt
              KUBE_API="https://kubernetes.default.svc:443"

              kube_get() {
                wget -q -O - --header "Authorization: Bearer ${SA_TOKEN}" "${KUBE_API}${1}"
              }

              kube_post() {
                wget -q -O - --header "Authorization: Bearer ${SA_TOKEN}" \
                  --header "Content-Type: application/json" \
                  --post-data "$2" "${KUBE_API}${1}"
              }

              kube_secret_field() {
                kube_get "/api/v1/namespaces/$1/secrets/$2" | \
                  awk -F'"' -v key="$3" '{for(i=1;i<=NF;i++) if($i==key){print $(i+2); exit}}'
              }

              kube_secret_exists() {
                kube_get "/api/v1/namespaces/$1/secrets/$2" >/dev/null 2>&1
              }

              # Wait for Vault to be responding (even if sealed/uninitialized)
              # Exit codes: 0=unsealed, 1=error, 2=sealed (includes uninitialized)
              echo "Waiting for Vault to be available..."
              MAX_RETRIES=60
              RETRY_COUNT=0
              while true; do
                set +e  # Temporarily disable exit on error for status check
                vault status >/dev/null 2>&1
                rc=$?
                set -e
                if [ $rc -eq 0 ] || [ $rc -eq 2 ]; then
                  echo "Vault is responding (exit code $rc)"
                  break
                fi
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -ge $MAX_RETRIES ]; then
                  echo "ERROR: Vault did not become available after $MAX_RETRIES attempts"
                  exit 1
                fi
                echo "Vault not ready (exit code $rc), waiting... (attempt $RETRY_COUNT/$MAX_RETRIES)"
                sleep 2
              done

              # Check if Vault is initialized
              if vault status | grep -q "Initialized.*false"; then
                echo "Initializing Vault..."
                # With Transit auto-unseal, use recovery shares instead of key shares
                vault operator init -recovery-shares=1 -recovery-threshold=1 -format=json > /tmp/init.json
                cat /tmp/init.json

                # Extract root token using sed (more reliable than grep for JSON)
                ROOT_TOKEN=$(sed -n 's/.*"root_token": *"\([^"]*\)".*/\1/p' /tmp/init.json)
                echo "Extracted root token: ${ROOT_TOKEN:0:10}..."

                # Store root token in Kubernetes secret
                kube_post "/api/v1/namespaces/{{ .Release.Namespace }}/secrets" \
                  "{\"apiVersion\":\"v1\",\"kind\":\"Secret\",\"metadata\":{\"name\":\"vault-root-token\",\"namespace\":\"{{ .Release.Namespace }}\"},\"type\":\"Opaque\",\"stringData\":{\"token\":\"${ROOT_TOKEN}\"}}"

                echo "Vault initialized and root token stored"
              else
                echo "Vault already initialized"
                # Get root token from secret
                ROOT_TOKEN=$(kube_secret_field "{{ .Release.Namespace }}" "vault-root-token" "token" | base64 -d)
              fi

              # Wait for Vault to be unsealed (auto-unseal should handle this)
              echo "Waiting for Vault to be unsealed..."
              until vault status 2>/dev/null | grep -q "Sealed.*false"; do
                echo "Vault still sealed, waiting..."
                sleep 2
              done

              echo "Vault is unsealed, proceeding with configuration..."

              # Login with root token
              vault login "$ROOT_TOKEN"

              # Enable KV-v2 secrets engine
              echo "Enabling KV-v2 secrets engine..."
              vault secrets enable -path=secret kv-v2 2>/dev/null || echo "KV-v2 already enabled"

              # Apply policies
              echo "Applying policies..."
              vault policy write monitoring /config/policy-monitoring.hcl
              vault policy write argocd /config/policy-argocd.hcl
              vault policy write keycloak /config/policy-keycloak.hcl
              vault policy write oidc-user /config/policy-oidc-user.hcl

              # Configure Kubernetes auth
              echo "Configuring Kubernetes auth..."
              vault auth enable kubernetes 2>/dev/null || echo "Kubernetes auth already enabled"
              vault write auth/kubernetes/config \
                kubernetes_host="https://kubernetes.default.svc:443"

              # Create vault-secrets-operator role (for future in-cluster dynamic secrets)
              echo "Creating Kubernetes auth roles..."
              vault write auth/kubernetes/role/vault-secrets-operator \
                bound_service_account_names="vault-secrets-operator-controller-manager,default" \
                bound_service_account_namespaces="vault-secrets-operator,monitoring,argocd,keycloak,vault" \
                policies="monitoring,argocd,keycloak" \
                ttl=24h

              # Note: Static secrets are now stored in Transit Vault and pulled by VSO
              # This in-cluster Vault is available for future dynamic secrets (AWS, DB, PKI)

              # Read OIDC client secret from Transit Vault secret for OIDC config
              # VSO will create this secret once it syncs
              echo "Waiting for vault-oidc-secret to be available..."
              OIDC_SECRET_RETRIES=30
              OIDC_SECRET_COUNT=0
              while ! kube_secret_exists "{{ .Release.Namespace }}" "vault-oidc-secret"; do
                OIDC_SECRET_COUNT=$((OIDC_SECRET_COUNT + 1))
                if [ $OIDC_SECRET_COUNT -ge $OIDC_SECRET_RETRIES ]; then
                  echo "WARNING: vault-oidc-secret not found after $OIDC_SECRET_RETRIES attempts, skipping OIDC config"
                  break
                fi
                echo "Waiting for VSO to create vault-oidc-secret... (attempt $OIDC_SECRET_COUNT/$OIDC_SECRET_RETRIES)"
                sleep 5
              done

              if kube_secret_exists "{{ .Release.Namespace }}" "vault-oidc-secret"; then
                VAULT_OIDC_CLIENT_SECRET=$(kube_secret_field "{{ .Release.Namespace }}" "vault-oidc-secret" "vault-client-secret" | base64 -d)
              fi

              # Configure OIDC auth method for Vault UI login
              # Uses external Keycloak URL with Gateway CA certificate
              echo "Configuring OIDC auth method..."
              vault auth enable oidc 2>/dev/null || echo "OIDC auth already enabled"

              # Wait for Keycloak to be ready (use internal URL for health check)
              echo "Waiting for Keycloak OIDC discovery..."
              OIDC_RETRIES=30
              OIDC_COUNT=0
              KEYCLOAK_INTERNAL_URL="http://keycloak-keycloakx-http.keycloak.svc:{{ .Values.ports.keycloak.http }}/realms/devsecops"
              KEYCLOAK_EXTERNAL_URL="https://keycloak.localhost/realms/devsecops"
              while ! wget -q --spider "$KEYCLOAK_INTERNAL_URL/.well-known/openid-configuration" 2>/dev/null; do
                OIDC_COUNT=$((OIDC_COUNT + 1))
                if [ $OIDC_COUNT -ge $OIDC_RETRIES ]; then
                  echo "WARNING: Keycloak not ready after $OIDC_RETRIES attempts, skipping OIDC config"
                  break
                fi
                echo "Keycloak not ready, waiting... (attempt $OIDC_COUNT/$OIDC_RETRIES)"
                sleep 5
              done

              if [ $OIDC_COUNT -lt $OIDC_RETRIES ] && [ -n "$VAULT_OIDC_CLIENT_SECRET" ]; then
                # Fetch Gateway CA certificate for TLS verification
                echo "Fetching Gateway TLS certificate..."
                GATEWAY_CA_CERT=$(kube_secret_field "gateway" "gateway-tls" "tls.crt" | base64 -d)

                if [ -n "$GATEWAY_CA_CERT" ]; then
                  vault write auth/oidc/config \
                    oidc_discovery_url="$KEYCLOAK_EXTERNAL_URL" \
                    oidc_client_id="vault" \
                    oidc_client_secret="$VAULT_OIDC_CLIENT_SECRET" \
                    oidc_discovery_ca_pem="$GATEWAY_CA_CERT" \
                    default_role="default"
                  vault write auth/oidc/role/default \
                    bound_audiences="vault" \
                    allowed_redirect_uris="https://vault.localhost/ui/vault/auth/oidc/oidc/callback" \
                    user_claim="preferred_username" \
                    groups_claim="groups" \
                    policies="default,oidc-user"
                  echo "OIDC auth method configured with external URL"
                else
                  echo "WARNING: Gateway TLS secret not found, skipping OIDC config"
                fi
              else
                echo "WARNING: Skipping OIDC config (Keycloak not ready or OIDC secret not available)"
              fi

              echo "=== Vault Bootstrap Complete ==="
          volumeMounts:
            - name: config
              mountPath: /config
              readOnly: true
      volumes:
        - name: config
          configMap:
            name: vault-bootstrap-config
---
# RBAC for bootstrap job to create secrets
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: vault-bootstrap
  namespace: {{ .Release.Namespace }}
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "create", "update", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: vault-bootstrap
  namespace: {{ .Release.Namespace }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: vault-bootstrap
subjects:
  - kind: ServiceAccount
    name: {{ .Release.Name }}
    namespace: {{ .Release.Namespace }}
---
# Role in gateway namespace to read gateway-tls secret
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: vault-bootstrap-gateway-reader
  namespace: gateway
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    resourceNames: ["gateway-tls"]
    verbs: ["get"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: vault-bootstrap-gateway-reader
  namespace: gateway
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: vault-bootstrap-gateway-reader
subjects:
  - kind: ServiceAccount
    name: {{ .Release.Name }}
    namespace: {{ .Release.Namespace }}
---
# Network policy for bootstrap job
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: vault-bootstrap
  namespace: {{ .Release.Namespace }}
spec:
  endpointSelector:
    matchLabels:
      app.kubernetes.io/name: vault-bootstrap

  egress:
    # Allow DNS resolution
    - toEndpoints:
        - matchLabels:
            k8s:io.kubernetes.pod.namespace: kube-system
            k8s-app: kube-dns
      toPorts:
        - ports:
            - port: "{{ .Values.ports.dns }}"
              protocol: UDP

    # Allow Kubernetes API access (for secret reads/creates)
    - toEntities:
        - kube-apiserver

    # Allow connection to Vault server
    - toEndpoints:
        - matchLabels:
            app.kubernetes.io/name: vault
            component: server
      toPorts:
        - ports:
            - port: "{{ .Values.ports.vault.http }}"
              protocol: TCP

    # Allow connection to Keycloak for OIDC discovery
    - toEndpoints:
        - matchLabels:
            k8s:io.kubernetes.pod.namespace: keycloak
            app.kubernetes.io/name: keycloakx
      toPorts:
        - ports:
            - port: "{{ .Values.ports.keycloak.http }}"
              protocol: TCP
{{- end }}
